"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/chat/[session_id]/page",{

/***/ "(app-pages-browser)/./hooks/useChat.ts":
/*!**************************!*\
  !*** ./hooks/useChat.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChat: function() { return /* binding */ useChat; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ useChat auto */ \nfunction useChat() {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const loadHistory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (sessionId)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const historyResponse = await fetch(\"http://127.0.0.1:8001/api/v1/sessions/\".concat(sessionId, \"/history\"));\n            if (historyResponse.ok) {\n                const historyData = await historyResponse.json();\n                const sessionMessages = historyData.messages.map((msg)=>{\n                    const messageObj = {\n                        id: \"\".concat(msg.role, \"-\").concat(Date.now(), \"-\").concat(Math.random()),\n                        role: msg.role,\n                        content: msg.content,\n                        timestamp: new Date(msg.timestamp || Date.now())\n                    };\n                    // For assistant messages, include the full response data for visualizations\n                    if (msg.role === \"assistant\" && msg.full_response) {\n                        messageObj.response = {\n                            type: msg.full_response.type || \"text\",\n                            data: msg.full_response.data || [],\n                            summary: msg.full_response.summary || msg.full_response.reasoning || \"No summary available\",\n                            // Include additional response metadata\n                            sql_query: msg.full_response.sql_query,\n                            row_count: msg.full_response.row_count,\n                            confidence_score: msg.full_response.confidence_score,\n                            execution_time: msg.full_response.execution_time,\n                            reasoning: msg.full_response.reasoning,\n                            success: msg.full_response.success,\n                            // Store the complete response data for future context retrieval\n                            full_response: msg.full_response\n                        };\n                    } else if (msg.response) {\n                        // Preserve existing response format for backward compatibility\n                        messageObj.response = msg.response;\n                    }\n                    return messageObj;\n                });\n                setMessages(sessionMessages);\n            }\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"An unexpected error occurred\");\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        setMessages\n    ]);\n    const sendInitialMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (query, sessionId)=>{\n        setIsLoading(true);\n        setError(null);\n        try {\n            const userMessage = {\n                id: \"user-\".concat(Date.now()),\n                role: \"user\",\n                content: query,\n                timestamp: new Date()\n            };\n            setMessages((prev)=>[\n                    ...prev,\n                    userMessage\n                ]);\n            const response = await fetch(\"/api/chat\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    query,\n                    sessionId\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Error: \".concat(response.status));\n            }\n            const responseData = await response.json();\n            if (responseData.messages && responseData.messages.length > 0) {\n                const assistantMessages = responseData.messages.filter((msg)=>msg.role === \"assistant\");\n                const latestAssistantMessage = assistantMessages[assistantMessages.length - 1];\n                if (latestAssistantMessage) {\n                    setMessages((prev)=>[\n                            ...prev,\n                            latestAssistantMessage\n                        ]);\n                }\n            }\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"An unexpected error occurred\");\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        setMessages\n    ]);\n    const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (query, sessionId)=>{\n        if (!query.trim()) return [];\n        setIsLoading(true);\n        setError(null);\n        try {\n            const requestBody = {\n                query\n            };\n            if (sessionId) {\n                requestBody.session_id = sessionId;\n            }\n            const controller = new AbortController();\n            const timeoutId = setTimeout(()=>controller.abort(), 60000); // 60 seconds timeout\n            const response = await fetch(\"/api/chat\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    query,\n                    sessionId\n                }),\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            if (!response.ok) {\n                throw new Error(\"Error: \".concat(response.status));\n            }\n            const responseData = await response.json();\n            let newMessages = [];\n            if (responseData.messages && responseData.messages.length > 0) {\n                const assistantMessages = responseData.messages.filter((msg)=>msg.role === \"assistant\");\n                const latestAssistantMessage = assistantMessages[assistantMessages.length - 1];\n                if (latestAssistantMessage) {\n                    setMessages((prev)=>{\n                        newMessages = [\n                            ...prev,\n                            latestAssistantMessage\n                        ];\n                        return newMessages;\n                    });\n                }\n            }\n            return newMessages;\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"An unexpected error occurred\");\n            const errorMessage = {\n                id: \"error-\".concat(Date.now()),\n                role: \"assistant\",\n                content: \"Sorry, I encountered an error while processing your request. Please try again.\",\n                timestamp: new Date(),\n                response: {\n                    type: \"text\",\n                    summary: \"Error: Unable to process request\"\n                }\n            };\n            let newMessages = [];\n            setMessages((prev)=>{\n                newMessages = [\n                    ...prev,\n                    errorMessage\n                ];\n                return newMessages;\n            });\n            return newMessages;\n        } finally{\n            setIsLoading(false);\n        }\n    }, [\n        setMessages\n    ]);\n    const clearChat = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        setMessages([]);\n        setError(null);\n    }, []);\n    const setMessagesDirectly = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((newMessages)=>{\n        setMessages(newMessages);\n    }, []);\n    return {\n        messages,\n        isLoading,\n        error,\n        sendMessage,\n        sendInitialMessage,\n        loadHistory,\n        clearChat,\n        setMessagesDirectly\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBT0E7UUFDVCxTQUFVO1lBQ1I5RCxhQUFhO1FBQ2Y7SUFDRixHQUFHO1FBQUNGO0tBQVk7SUFFaEIsTUFBTWtFLFlBQVlyRSxrREFBV0EsQ0FBQztRQUM1QkcsWUFBWSxFQUFFO1FBQ2RJLFNBQVM7SUFDWCxHQUFHLEVBQUU7SUFFTCxNQUFNK0Qsc0JBQXNCdEUsa0RBQVdBLENBQUMsQ0FBQ21FO1FBQ3ZDaEUsWUFBWWdFO0lBQ2QsR0FBRyxFQUFFO0lBRUwsT0FBTztRQUNMakU7UUFDQUU7UUFDQUU7UUFDQWtEO1FBQ0FmO1FBQ0FqQztRQUNBNkQ7UUFDQUM7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZUNoYXQudHM/YzJkYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IENoYXRNZXNzYWdlLCBBcGlSZXNwb25zZSB9IGZyb20gJ0AvdHlwZXMvY2hhdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGF0KCkge1xuICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlPENoYXRNZXNzYWdlW10+KFtdKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICBjb25zdCBsb2FkSGlzdG9yeSA9IHVzZUNhbGxiYWNrKGFzeW5jIChzZXNzaW9uSWQ6IHN0cmluZykgPT4ge1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBoaXN0b3J5UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cDovLzEyNy4wLjAuMTo4MDAxL2FwaS92MS9zZXNzaW9ucy8ke3Nlc3Npb25JZH0vaGlzdG9yeWApO1xuICAgICAgaWYgKGhpc3RvcnlSZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBoaXN0b3J5RGF0YSA9IGF3YWl0IGhpc3RvcnlSZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IHNlc3Npb25NZXNzYWdlczogQ2hhdE1lc3NhZ2VbXSA9IGhpc3RvcnlEYXRhLm1lc3NhZ2VzLm1hcCgobXNnOiBhbnkpID0+IHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlT2JqOiBDaGF0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGlkOiBgJHttc2cucm9sZX0tJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCl9YCxcbiAgICAgICAgICAgIHJvbGU6IG1zZy5yb2xlLFxuICAgICAgICAgICAgY29udGVudDogbXNnLmNvbnRlbnQsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKG1zZy50aW1lc3RhbXAgfHwgRGF0ZS5ub3coKSksXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGb3IgYXNzaXN0YW50IG1lc3NhZ2VzLCBpbmNsdWRlIHRoZSBmdWxsIHJlc3BvbnNlIGRhdGEgZm9yIHZpc3VhbGl6YXRpb25zXG4gICAgICAgICAgaWYgKG1zZy5yb2xlID09PSAnYXNzaXN0YW50JyAmJiBtc2cuZnVsbF9yZXNwb25zZSkge1xuICAgICAgICAgICAgbWVzc2FnZU9iai5yZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogbXNnLmZ1bGxfcmVzcG9uc2UudHlwZSB8fCAndGV4dCcsXG4gICAgICAgICAgICAgIGRhdGE6IG1zZy5mdWxsX3Jlc3BvbnNlLmRhdGEgfHwgW10sXG4gICAgICAgICAgICAgIHN1bW1hcnk6IG1zZy5mdWxsX3Jlc3BvbnNlLnN1bW1hcnkgfHwgbXNnLmZ1bGxfcmVzcG9uc2UucmVhc29uaW5nIHx8ICdObyBzdW1tYXJ5IGF2YWlsYWJsZScsXG4gICAgICAgICAgICAgIC8vIEluY2x1ZGUgYWRkaXRpb25hbCByZXNwb25zZSBtZXRhZGF0YVxuICAgICAgICAgICAgICBzcWxfcXVlcnk6IG1zZy5mdWxsX3Jlc3BvbnNlLnNxbF9xdWVyeSxcbiAgICAgICAgICAgICAgcm93X2NvdW50OiBtc2cuZnVsbF9yZXNwb25zZS5yb3dfY291bnQsXG4gICAgICAgICAgICAgIGNvbmZpZGVuY2Vfc2NvcmU6IG1zZy5mdWxsX3Jlc3BvbnNlLmNvbmZpZGVuY2Vfc2NvcmUsXG4gICAgICAgICAgICAgIGV4ZWN1dGlvbl90aW1lOiBtc2cuZnVsbF9yZXNwb25zZS5leGVjdXRpb25fdGltZSxcbiAgICAgICAgICAgICAgcmVhc29uaW5nOiBtc2cuZnVsbF9yZXNwb25zZS5yZWFzb25pbmcsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IG1zZy5mdWxsX3Jlc3BvbnNlLnN1Y2Nlc3MsXG4gICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjb21wbGV0ZSByZXNwb25zZSBkYXRhIGZvciBmdXR1cmUgY29udGV4dCByZXRyaWV2YWxcbiAgICAgICAgICAgICAgZnVsbF9yZXNwb25zZTogbXNnLmZ1bGxfcmVzcG9uc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIGlmIChtc2cucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGV4aXN0aW5nIHJlc3BvbnNlIGZvcm1hdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgbWVzc2FnZU9iai5yZXNwb25zZSA9IG1zZy5yZXNwb25zZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2VPYmo7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXRNZXNzYWdlcyhzZXNzaW9uTWVzc2FnZXMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkJyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbc2V0TWVzc2FnZXNdKTtcblxuICBjb25zdCBzZW5kSW5pdGlhbE1lc3NhZ2UgPSB1c2VDYWxsYmFjayhhc3luYyAocXVlcnk6IHN0cmluZywgc2Vzc2lvbklkOiBzdHJpbmcpID0+IHtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdXNlck1lc3NhZ2U6IENoYXRNZXNzYWdlID0ge1xuICAgICAgICBpZDogYHVzZXItJHtEYXRlLm5vdygpfWAsXG4gICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgY29udGVudDogcXVlcnksXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgIH07XG4gICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCB1c2VyTWVzc2FnZV0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2NoYXQnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2VEYXRhLm1lc3NhZ2VzICYmIHJlc3BvbnNlRGF0YS5tZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGFzc2lzdGFudE1lc3NhZ2VzID0gcmVzcG9uc2VEYXRhLm1lc3NhZ2VzLmZpbHRlcigobXNnOiBDaGF0TWVzc2FnZSkgPT4gbXNnLnJvbGUgPT09ICdhc3Npc3RhbnQnKTtcbiAgICAgICAgY29uc3QgbGF0ZXN0QXNzaXN0YW50TWVzc2FnZSA9IGFzc2lzdGFudE1lc3NhZ2VzW2Fzc2lzdGFudE1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICBcbiAgICAgICAgaWYgKGxhdGVzdEFzc2lzdGFudE1lc3NhZ2UpIHtcbiAgICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCBsYXRlc3RBc3Npc3RhbnRNZXNzYWdlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCcpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW3NldE1lc3NhZ2VzXSk7XG5cbiAgY29uc3Qgc2VuZE1lc3NhZ2UgPSB1c2VDYWxsYmFjayhhc3luYyAocXVlcnk6IHN0cmluZywgc2Vzc2lvbklkPzogc3RyaW5nKTogUHJvbWlzZTxDaGF0TWVzc2FnZVtdPiA9PiB7XG4gICAgaWYgKCFxdWVyeS50cmltKCkpIHJldHVybiBbXTtcblxuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXF1ZXN0Qm9keTogYW55ID0geyBxdWVyeSB9O1xuICAgICAgaWYgKHNlc3Npb25JZCkge1xuICAgICAgICByZXF1ZXN0Qm9keS5zZXNzaW9uX2lkID0gc2Vzc2lvbklkO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIDYwMDAwKTsgLy8gNjAgc2Vjb25kcyB0aW1lb3V0XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvY2hhdCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcXVlcnksXG4gICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICB9KSxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIH0pO1xuXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICBsZXQgbmV3TWVzc2FnZXM6IENoYXRNZXNzYWdlW10gPSBbXTtcbiAgICAgIGlmIChyZXNwb25zZURhdGEubWVzc2FnZXMgJiYgcmVzcG9uc2VEYXRhLm1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYXNzaXN0YW50TWVzc2FnZXMgPSByZXNwb25zZURhdGEubWVzc2FnZXMuZmlsdGVyKChtc2c6IENoYXRNZXNzYWdlKSA9PiBtc2cucm9sZSA9PT0gJ2Fzc2lzdGFudCcpO1xuICAgICAgICBjb25zdCBsYXRlc3RBc3Npc3RhbnRNZXNzYWdlID0gYXNzaXN0YW50TWVzc2FnZXNbYXNzaXN0YW50TWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIFxuICAgICAgICBpZiAobGF0ZXN0QXNzaXN0YW50TWVzc2FnZSkge1xuICAgICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4ge1xuICAgICAgICAgICAgbmV3TWVzc2FnZXMgPSBbLi4ucHJldiwgbGF0ZXN0QXNzaXN0YW50TWVzc2FnZV07XG4gICAgICAgICAgICByZXR1cm4gbmV3TWVzc2FnZXM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdNZXNzYWdlcztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCcpO1xuICAgICAgXG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2U6IENoYXRNZXNzYWdlID0ge1xuICAgICAgICBpZDogYGVycm9yLSR7RGF0ZS5ub3coKX1gLFxuICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgY29udGVudDogJ1NvcnJ5LCBJIGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIHByb2Nlc3NpbmcgeW91ciByZXF1ZXN0LiBQbGVhc2UgdHJ5IGFnYWluLicsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgc3VtbWFyeTogJ0Vycm9yOiBVbmFibGUgdG8gcHJvY2VzcyByZXF1ZXN0JyxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIGxldCBuZXdNZXNzYWdlczogQ2hhdE1lc3NhZ2VbXSA9IFtdO1xuICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiB7XG4gICAgICAgIG5ld01lc3NhZ2VzID0gWy4uLnByZXYsIGVycm9yTWVzc2FnZV07XG4gICAgICAgIHJldHVybiBuZXdNZXNzYWdlcztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ld01lc3NhZ2VzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW3NldE1lc3NhZ2VzXSk7XG5cbiAgY29uc3QgY2xlYXJDaGF0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldE1lc3NhZ2VzKFtdKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHNldE1lc3NhZ2VzRGlyZWN0bHkgPSB1c2VDYWxsYmFjaygobmV3TWVzc2FnZXM6IENoYXRNZXNzYWdlW10pID0+IHtcbiAgICBzZXRNZXNzYWdlcyhuZXdNZXNzYWdlcyk7XG4gIH0sIFtdKTtcblxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzLFxuICAgIGlzTG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBzZW5kTWVzc2FnZSxcbiAgICBzZW5kSW5pdGlhbE1lc3NhZ2UsXG4gICAgbG9hZEhpc3RvcnksXG4gICAgY2xlYXJDaGF0LFxuICAgIHNldE1lc3NhZ2VzRGlyZWN0bHksXG4gIH07XG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VDaGF0IiwibWVzc2FnZXMiLCJzZXRNZXNzYWdlcyIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJsb2FkSGlzdG9yeSIsInNlc3Npb25JZCIsImhpc3RvcnlSZXNwb25zZSIsImZldGNoIiwib2siLCJoaXN0b3J5RGF0YSIsImpzb24iLCJzZXNzaW9uTWVzc2FnZXMiLCJtYXAiLCJtc2ciLCJtZXNzYWdlT2JqIiwiaWQiLCJEYXRlIiwicm9sZSIsIk1hdGgiLCJub3ciLCJyYW5kb20iLCJjb250ZW50IiwidGltZXN0YW1wIiwiZnVsbF9yZXNwb25zZSIsInJlc3BvbnNlIiwidHlwZSIsImRhdGEiLCJzdW1tYXJ5IiwicmVhc29uaW5nIiwic3FsX3F1ZXJ5Iiwicm93X2NvdW50IiwiY29uZmlkZW5jZV9zY29yZSIsImV4ZWN1dGlvbl90aW1lIiwic3VjY2VzcyIsImVyciIsIkVycm9yIiwibWVzc2FnZSIsInNlbmRJbml0aWFsTWVzc2FnZSIsInF1ZXJ5IiwidXNlck1lc3NhZ2UiLCJwcmV2IiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhdHVzIiwicmVzcG9uc2VEYXRhIiwibGVuZ3RoIiwiYXNzaXN0YW50TWVzc2FnZXMiLCJmaWx0ZXIiLCJsYXRlc3RBc3Npc3RhbnRNZXNzYWdlIiwic2VuZE1lc3NhZ2UiLCJ0cmltIiwicmVxdWVzdEJvZHkiLCJzZXNzaW9uX2lkIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJhYm9ydCIsInNpZ25hbCIsImNsZWFyVGltZW91dCIsIm5ld01lc3NhZ2VzIiwiZXJyb3JNZXNzYWdlIiwiY2xlYXJDaGF0Iiwic2V0TWVzc2FnZXNEaXJlY3RseSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useChat.ts\n"));

/***/ })

});