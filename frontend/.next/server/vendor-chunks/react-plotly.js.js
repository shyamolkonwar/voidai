"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-plotly.js";
exports.ids = ["vendor-chunks/react-plotly.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-plotly.js/factory.js":
/*!*************************************************!*\
  !*** ./node_modules/react-plotly.js/factory.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = plotComponentFactory;\n\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// The naming convention is:\n//   - events are attached as `'plotly_' + eventName.toLowerCase()`\n//   - react props are `'on' + eventName`\nvar eventNames = ['AfterExport', 'AfterPlot', 'Animated', 'AnimatingFrame', 'AnimationInterrupted', 'AutoSize', 'BeforeExport', 'BeforeHover', 'ButtonClicked', 'Click', 'ClickAnnotation', 'Deselect', 'DoubleClick', 'Framework', 'Hover', 'LegendClick', 'LegendDoubleClick', 'Relayout', 'Relayouting', 'Restyle', 'Redraw', 'Selected', 'Selecting', 'SliderChange', 'SliderEnd', 'SliderStart', 'SunburstClick', 'Transitioning', 'TransitionInterrupted', 'Unhover', 'WebGlContextLost'];\nvar updateEvents = ['plotly_restyle', 'plotly_redraw', 'plotly_relayout', 'plotly_relayouting', 'plotly_doubleclick', 'plotly_animated', 'plotly_sunburstclick']; // Check if a window is available since SSR (server-side rendering)\n// breaks unnecessarily if you try to use it server-side.\n\nvar isBrowser = typeof window !== 'undefined';\n\nfunction plotComponentFactory(Plotly) {\n  var PlotlyComponent = /*#__PURE__*/function (_Component) {\n    _inherits(PlotlyComponent, _Component);\n\n    var _super = _createSuper(PlotlyComponent);\n\n    function PlotlyComponent(props) {\n      var _this;\n\n      _classCallCheck(this, PlotlyComponent);\n\n      _this = _super.call(this, props);\n      _this.p = Promise.resolve();\n      _this.resizeHandler = null;\n      _this.handlers = {};\n      _this.syncWindowResize = _this.syncWindowResize.bind(_assertThisInitialized(_this));\n      _this.syncEventHandlers = _this.syncEventHandlers.bind(_assertThisInitialized(_this));\n      _this.attachUpdateEvents = _this.attachUpdateEvents.bind(_assertThisInitialized(_this));\n      _this.getRef = _this.getRef.bind(_assertThisInitialized(_this));\n      _this.handleUpdate = _this.handleUpdate.bind(_assertThisInitialized(_this));\n      _this.figureCallback = _this.figureCallback.bind(_assertThisInitialized(_this));\n      _this.updatePlotly = _this.updatePlotly.bind(_assertThisInitialized(_this));\n      return _this;\n    }\n\n    _createClass(PlotlyComponent, [{\n      key: \"updatePlotly\",\n      value: function updatePlotly(shouldInvokeResizeHandler, figureCallbackFunction, shouldAttachUpdateEvents) {\n        var _this2 = this;\n\n        this.p = this.p.then(function () {\n          if (_this2.unmounting) {\n            return;\n          }\n\n          if (!_this2.el) {\n            throw new Error('Missing element reference');\n          } // eslint-disable-next-line consistent-return\n\n\n          return Plotly.react(_this2.el, {\n            data: _this2.props.data,\n            layout: _this2.props.layout,\n            config: _this2.props.config,\n            frames: _this2.props.frames\n          });\n        }).then(function () {\n          if (_this2.unmounting) {\n            return;\n          }\n\n          _this2.syncWindowResize(shouldInvokeResizeHandler);\n\n          _this2.syncEventHandlers();\n\n          _this2.figureCallback(figureCallbackFunction);\n\n          if (shouldAttachUpdateEvents) {\n            _this2.attachUpdateEvents();\n          }\n        })[\"catch\"](function (err) {\n          if (_this2.props.onError) {\n            _this2.props.onError(err);\n          }\n        });\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        this.unmounting = false;\n        this.updatePlotly(true, this.props.onInitialized, true);\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        this.unmounting = false; // frames *always* changes identity so fall back to check length only :(\n\n        var numPrevFrames = prevProps.frames && prevProps.frames.length ? prevProps.frames.length : 0;\n        var numNextFrames = this.props.frames && this.props.frames.length ? this.props.frames.length : 0;\n        var figureChanged = !(prevProps.layout === this.props.layout && prevProps.data === this.props.data && prevProps.config === this.props.config && numNextFrames === numPrevFrames);\n        var revisionDefined = prevProps.revision !== void 0;\n        var revisionChanged = prevProps.revision !== this.props.revision;\n\n        if (!figureChanged && (!revisionDefined || revisionDefined && !revisionChanged)) {\n          return;\n        }\n\n        this.updatePlotly(false, this.props.onUpdate, false);\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this.unmounting = true;\n        this.figureCallback(this.props.onPurge);\n\n        if (this.resizeHandler && isBrowser) {\n          window.removeEventListener('resize', this.resizeHandler);\n          this.resizeHandler = null;\n        }\n\n        this.removeUpdateEvents();\n        Plotly.purge(this.el);\n      }\n    }, {\n      key: \"attachUpdateEvents\",\n      value: function attachUpdateEvents() {\n        var _this3 = this;\n\n        if (!this.el || !this.el.removeListener) {\n          return;\n        }\n\n        updateEvents.forEach(function (updateEvent) {\n          _this3.el.on(updateEvent, _this3.handleUpdate);\n        });\n      }\n    }, {\n      key: \"removeUpdateEvents\",\n      value: function removeUpdateEvents() {\n        var _this4 = this;\n\n        if (!this.el || !this.el.removeListener) {\n          return;\n        }\n\n        updateEvents.forEach(function (updateEvent) {\n          _this4.el.removeListener(updateEvent, _this4.handleUpdate);\n        });\n      }\n    }, {\n      key: \"handleUpdate\",\n      value: function handleUpdate() {\n        this.figureCallback(this.props.onUpdate);\n      }\n    }, {\n      key: \"figureCallback\",\n      value: function figureCallback(callback) {\n        if (typeof callback === 'function') {\n          var _this$el = this.el,\n              data = _this$el.data,\n              layout = _this$el.layout;\n          var frames = this.el._transitionData ? this.el._transitionData._frames : null;\n          var figure = {\n            data: data,\n            layout: layout,\n            frames: frames\n          };\n          callback(figure, this.el);\n        }\n      }\n    }, {\n      key: \"syncWindowResize\",\n      value: function syncWindowResize(invoke) {\n        var _this5 = this;\n\n        if (!isBrowser) {\n          return;\n        }\n\n        if (this.props.useResizeHandler && !this.resizeHandler) {\n          this.resizeHandler = function () {\n            return Plotly.Plots.resize(_this5.el);\n          };\n\n          window.addEventListener('resize', this.resizeHandler);\n\n          if (invoke) {\n            this.resizeHandler();\n          }\n        } else if (!this.props.useResizeHandler && this.resizeHandler) {\n          window.removeEventListener('resize', this.resizeHandler);\n          this.resizeHandler = null;\n        }\n      }\n    }, {\n      key: \"getRef\",\n      value: function getRef(el) {\n        this.el = el;\n\n        if (this.props.debug && isBrowser) {\n          window.gd = this.el;\n        }\n      } // Attach and remove event handlers as they're added or removed from props:\n\n    }, {\n      key: \"syncEventHandlers\",\n      value: function syncEventHandlers() {\n        var _this6 = this;\n\n        eventNames.forEach(function (eventName) {\n          var prop = _this6.props['on' + eventName];\n          var handler = _this6.handlers[eventName];\n          var hasHandler = Boolean(handler);\n\n          if (prop && !hasHandler) {\n            _this6.addEventHandler(eventName, prop);\n          } else if (!prop && hasHandler) {\n            // Needs to be removed:\n            _this6.removeEventHandler(eventName);\n          } else if (prop && hasHandler && prop !== handler) {\n            // replace the handler\n            _this6.removeEventHandler(eventName);\n\n            _this6.addEventHandler(eventName, prop);\n          }\n        });\n      }\n    }, {\n      key: \"addEventHandler\",\n      value: function addEventHandler(eventName, prop) {\n        this.handlers[eventName] = prop;\n        this.el.on(this.getPlotlyEventName(eventName), this.handlers[eventName]);\n      }\n    }, {\n      key: \"removeEventHandler\",\n      value: function removeEventHandler(eventName) {\n        this.el.removeListener(this.getPlotlyEventName(eventName), this.handlers[eventName]);\n        delete this.handlers[eventName];\n      }\n    }, {\n      key: \"getPlotlyEventName\",\n      value: function getPlotlyEventName(eventName) {\n        return 'plotly_' + eventName.toLowerCase();\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          id: this.props.divId,\n          style: this.props.style,\n          ref: this.getRef,\n          className: this.props.className\n        });\n      }\n    }]);\n\n    return PlotlyComponent;\n  }(_react.Component);\n\n  PlotlyComponent.propTypes = {\n    data: _propTypes[\"default\"].arrayOf(_propTypes[\"default\"].object),\n    config: _propTypes[\"default\"].object,\n    layout: _propTypes[\"default\"].object,\n    frames: _propTypes[\"default\"].arrayOf(_propTypes[\"default\"].object),\n    revision: _propTypes[\"default\"].number,\n    onInitialized: _propTypes[\"default\"].func,\n    onPurge: _propTypes[\"default\"].func,\n    onError: _propTypes[\"default\"].func,\n    onUpdate: _propTypes[\"default\"].func,\n    debug: _propTypes[\"default\"].bool,\n    style: _propTypes[\"default\"].object,\n    className: _propTypes[\"default\"].string,\n    useResizeHandler: _propTypes[\"default\"].bool,\n    divId: _propTypes[\"default\"].string\n  };\n  eventNames.forEach(function (eventName) {\n    PlotlyComponent.propTypes['on' + eventName] = _propTypes[\"default\"].func;\n  });\n  PlotlyComponent.defaultProps = {\n    debug: false,\n    useResizeHandler: false,\n    data: [],\n    style: {\n      position: 'relative',\n      display: 'inline-block'\n    }\n  };\n  return PlotlyComponent;\n}\n//# sourceMappingURL=factory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGxvdGx5LmpzL2ZhY3RvcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsd0JBQXdCLDJCQUEyQixzR0FBc0cscUJBQXFCLG1CQUFtQiw4SEFBOEg7O0FBRS9ULDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFrQjs7QUFFbEIscUNBQXFDLG1CQUFPLENBQUMsd0dBQU87O0FBRXBELHdDQUF3QyxtQkFBTyxDQUFDLDREQUFZOztBQUU1RCx1Q0FBdUMsdUNBQXVDOztBQUU5RSxpREFBaUQsZ0RBQWdELHVDQUF1QyxzQ0FBc0Msb0ZBQW9GLDREQUE0RDs7QUFFOVQscURBQXFELDZDQUE2QyxjQUFjLDhFQUE4RSxTQUFTLG9CQUFvQixtREFBbUQsK0JBQStCLHlCQUF5QixpQkFBaUIsc0ZBQXNGLHVCQUF1QiwyRUFBMkUscUZBQXFGLHNDQUFzQyw0Q0FBNEMsT0FBTyw4QkFBOEIseUJBQXlCLGFBQWEsMEJBQTBCOztBQUUzeEIsa0RBQWtELDBDQUEwQzs7QUFFNUYsNENBQTRDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQ7O0FBRS9QLDhEQUE4RCxzRUFBc0UsOERBQThELGtEQUFrRCxpQkFBaUIsR0FBRzs7QUFFeFEsMkNBQTJDLCtEQUErRCw2RUFBNkUseUVBQXlFLGVBQWUsdURBQXVELEdBQUcsK0NBQStDLGlCQUFpQixHQUFHOztBQUU1WSxpQ0FBaUMsMEdBQTBHLGlCQUFpQixhQUFhOztBQUV6SyxpQ0FBaUMsNkRBQTZELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCwyREFBMkQsT0FBTyx5Q0FBeUM7O0FBRXBYLGtEQUFrRCwwRUFBMEUsZUFBZSw0QkFBNEIsbUZBQW1GOztBQUUxUCx3Q0FBd0MsdUJBQXVCLHlGQUF5Rjs7QUFFeEosdUNBQXVDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNEVBQTRFLElBQUksZUFBZSxZQUFZOztBQUV4VCw4QkFBOEIsdUdBQXVHLG1EQUFtRDs7QUFFeEw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrS0FBa0s7QUFDbEs7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVIsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGxvdGx5LmpzL2ZhY3RvcnkuanM/NDhmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBwbG90Q29tcG9uZW50RmFjdG9yeTtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuLy8gVGhlIG5hbWluZyBjb252ZW50aW9uIGlzOlxuLy8gICAtIGV2ZW50cyBhcmUgYXR0YWNoZWQgYXMgYCdwbG90bHlfJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpYFxuLy8gICAtIHJlYWN0IHByb3BzIGFyZSBgJ29uJyArIGV2ZW50TmFtZWBcbnZhciBldmVudE5hbWVzID0gWydBZnRlckV4cG9ydCcsICdBZnRlclBsb3QnLCAnQW5pbWF0ZWQnLCAnQW5pbWF0aW5nRnJhbWUnLCAnQW5pbWF0aW9uSW50ZXJydXB0ZWQnLCAnQXV0b1NpemUnLCAnQmVmb3JlRXhwb3J0JywgJ0JlZm9yZUhvdmVyJywgJ0J1dHRvbkNsaWNrZWQnLCAnQ2xpY2snLCAnQ2xpY2tBbm5vdGF0aW9uJywgJ0Rlc2VsZWN0JywgJ0RvdWJsZUNsaWNrJywgJ0ZyYW1ld29yaycsICdIb3ZlcicsICdMZWdlbmRDbGljaycsICdMZWdlbmREb3VibGVDbGljaycsICdSZWxheW91dCcsICdSZWxheW91dGluZycsICdSZXN0eWxlJywgJ1JlZHJhdycsICdTZWxlY3RlZCcsICdTZWxlY3RpbmcnLCAnU2xpZGVyQ2hhbmdlJywgJ1NsaWRlckVuZCcsICdTbGlkZXJTdGFydCcsICdTdW5idXJzdENsaWNrJywgJ1RyYW5zaXRpb25pbmcnLCAnVHJhbnNpdGlvbkludGVycnVwdGVkJywgJ1VuaG92ZXInLCAnV2ViR2xDb250ZXh0TG9zdCddO1xudmFyIHVwZGF0ZUV2ZW50cyA9IFsncGxvdGx5X3Jlc3R5bGUnLCAncGxvdGx5X3JlZHJhdycsICdwbG90bHlfcmVsYXlvdXQnLCAncGxvdGx5X3JlbGF5b3V0aW5nJywgJ3Bsb3RseV9kb3VibGVjbGljaycsICdwbG90bHlfYW5pbWF0ZWQnLCAncGxvdGx5X3N1bmJ1cnN0Y2xpY2snXTsgLy8gQ2hlY2sgaWYgYSB3aW5kb3cgaXMgYXZhaWxhYmxlIHNpbmNlIFNTUiAoc2VydmVyLXNpZGUgcmVuZGVyaW5nKVxuLy8gYnJlYWtzIHVubmVjZXNzYXJpbHkgaWYgeW91IHRyeSB0byB1c2UgaXQgc2VydmVyLXNpZGUuXG5cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuZnVuY3Rpb24gcGxvdENvbXBvbmVudEZhY3RvcnkoUGxvdGx5KSB7XG4gIHZhciBQbG90bHlDb21wb25lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoUGxvdGx5Q29tcG9uZW50LCBfQ29tcG9uZW50KTtcblxuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUGxvdGx5Q29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFBsb3RseUNvbXBvbmVudChwcm9wcykge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxvdGx5Q29tcG9uZW50KTtcblxuICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcyk7XG4gICAgICBfdGhpcy5wID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICBfdGhpcy5yZXNpemVIYW5kbGVyID0gbnVsbDtcbiAgICAgIF90aGlzLmhhbmRsZXJzID0ge307XG4gICAgICBfdGhpcy5zeW5jV2luZG93UmVzaXplID0gX3RoaXMuc3luY1dpbmRvd1Jlc2l6ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIF90aGlzLnN5bmNFdmVudEhhbmRsZXJzID0gX3RoaXMuc3luY0V2ZW50SGFuZGxlcnMuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICBfdGhpcy5hdHRhY2hVcGRhdGVFdmVudHMgPSBfdGhpcy5hdHRhY2hVcGRhdGVFdmVudHMuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICBfdGhpcy5nZXRSZWYgPSBfdGhpcy5nZXRSZWYuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICBfdGhpcy5oYW5kbGVVcGRhdGUgPSBfdGhpcy5oYW5kbGVVcGRhdGUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgICBfdGhpcy5maWd1cmVDYWxsYmFjayA9IF90aGlzLmZpZ3VyZUNhbGxiYWNrLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgICAgX3RoaXMudXBkYXRlUGxvdGx5ID0gX3RoaXMudXBkYXRlUGxvdGx5LmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhQbG90bHlDb21wb25lbnQsIFt7XG4gICAgICBrZXk6IFwidXBkYXRlUGxvdGx5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlUGxvdGx5KHNob3VsZEludm9rZVJlc2l6ZUhhbmRsZXIsIGZpZ3VyZUNhbGxiYWNrRnVuY3Rpb24sIHNob3VsZEF0dGFjaFVwZGF0ZUV2ZW50cykge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB0aGlzLnAgPSB0aGlzLnAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzMi51bm1vdW50aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFfdGhpczIuZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBlbGVtZW50IHJlZmVyZW5jZScpO1xuICAgICAgICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cblxuICAgICAgICAgIHJldHVybiBQbG90bHkucmVhY3QoX3RoaXMyLmVsLCB7XG4gICAgICAgICAgICBkYXRhOiBfdGhpczIucHJvcHMuZGF0YSxcbiAgICAgICAgICAgIGxheW91dDogX3RoaXMyLnByb3BzLmxheW91dCxcbiAgICAgICAgICAgIGNvbmZpZzogX3RoaXMyLnByb3BzLmNvbmZpZyxcbiAgICAgICAgICAgIGZyYW1lczogX3RoaXMyLnByb3BzLmZyYW1lc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLnVubW91bnRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpczIuc3luY1dpbmRvd1Jlc2l6ZShzaG91bGRJbnZva2VSZXNpemVIYW5kbGVyKTtcblxuICAgICAgICAgIF90aGlzMi5zeW5jRXZlbnRIYW5kbGVycygpO1xuXG4gICAgICAgICAgX3RoaXMyLmZpZ3VyZUNhbGxiYWNrKGZpZ3VyZUNhbGxiYWNrRnVuY3Rpb24pO1xuXG4gICAgICAgICAgaWYgKHNob3VsZEF0dGFjaFVwZGF0ZUV2ZW50cykge1xuICAgICAgICAgICAgX3RoaXMyLmF0dGFjaFVwZGF0ZUV2ZW50cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaWYgKF90aGlzMi5wcm9wcy5vbkVycm9yKSB7XG4gICAgICAgICAgICBfdGhpczIucHJvcHMub25FcnJvcihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudW5tb3VudGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZVBsb3RseSh0cnVlLCB0aGlzLnByb3BzLm9uSW5pdGlhbGl6ZWQsIHRydWUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb21wb25lbnREaWRVcGRhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIHRoaXMudW5tb3VudGluZyA9IGZhbHNlOyAvLyBmcmFtZXMgKmFsd2F5cyogY2hhbmdlcyBpZGVudGl0eSBzbyBmYWxsIGJhY2sgdG8gY2hlY2sgbGVuZ3RoIG9ubHkgOihcblxuICAgICAgICB2YXIgbnVtUHJldkZyYW1lcyA9IHByZXZQcm9wcy5mcmFtZXMgJiYgcHJldlByb3BzLmZyYW1lcy5sZW5ndGggPyBwcmV2UHJvcHMuZnJhbWVzLmxlbmd0aCA6IDA7XG4gICAgICAgIHZhciBudW1OZXh0RnJhbWVzID0gdGhpcy5wcm9wcy5mcmFtZXMgJiYgdGhpcy5wcm9wcy5mcmFtZXMubGVuZ3RoID8gdGhpcy5wcm9wcy5mcmFtZXMubGVuZ3RoIDogMDtcbiAgICAgICAgdmFyIGZpZ3VyZUNoYW5nZWQgPSAhKHByZXZQcm9wcy5sYXlvdXQgPT09IHRoaXMucHJvcHMubGF5b3V0ICYmIHByZXZQcm9wcy5kYXRhID09PSB0aGlzLnByb3BzLmRhdGEgJiYgcHJldlByb3BzLmNvbmZpZyA9PT0gdGhpcy5wcm9wcy5jb25maWcgJiYgbnVtTmV4dEZyYW1lcyA9PT0gbnVtUHJldkZyYW1lcyk7XG4gICAgICAgIHZhciByZXZpc2lvbkRlZmluZWQgPSBwcmV2UHJvcHMucmV2aXNpb24gIT09IHZvaWQgMDtcbiAgICAgICAgdmFyIHJldmlzaW9uQ2hhbmdlZCA9IHByZXZQcm9wcy5yZXZpc2lvbiAhPT0gdGhpcy5wcm9wcy5yZXZpc2lvbjtcblxuICAgICAgICBpZiAoIWZpZ3VyZUNoYW5nZWQgJiYgKCFyZXZpc2lvbkRlZmluZWQgfHwgcmV2aXNpb25EZWZpbmVkICYmICFyZXZpc2lvbkNoYW5nZWQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVQbG90bHkoZmFsc2UsIHRoaXMucHJvcHMub25VcGRhdGUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy51bm1vdW50aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5maWd1cmVDYWxsYmFjayh0aGlzLnByb3BzLm9uUHVyZ2UpO1xuXG4gICAgICAgIGlmICh0aGlzLnJlc2l6ZUhhbmRsZXIgJiYgaXNCcm93c2VyKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplSGFuZGxlcik7XG4gICAgICAgICAgdGhpcy5yZXNpemVIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVtb3ZlVXBkYXRlRXZlbnRzKCk7XG4gICAgICAgIFBsb3RseS5wdXJnZSh0aGlzLmVsKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYXR0YWNoVXBkYXRlRXZlbnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoVXBkYXRlRXZlbnRzKCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICBpZiAoIXRoaXMuZWwgfHwgIXRoaXMuZWwucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAodXBkYXRlRXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMuZWwub24odXBkYXRlRXZlbnQsIF90aGlzMy5oYW5kbGVVcGRhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVtb3ZlVXBkYXRlRXZlbnRzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlVXBkYXRlRXZlbnRzKCkge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICBpZiAoIXRoaXMuZWwgfHwgIXRoaXMuZWwucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAodXBkYXRlRXZlbnQpIHtcbiAgICAgICAgICBfdGhpczQuZWwucmVtb3ZlTGlzdGVuZXIodXBkYXRlRXZlbnQsIF90aGlzNC5oYW5kbGVVcGRhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFuZGxlVXBkYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVXBkYXRlKCkge1xuICAgICAgICB0aGlzLmZpZ3VyZUNhbGxiYWNrKHRoaXMucHJvcHMub25VcGRhdGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmaWd1cmVDYWxsYmFja1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpZ3VyZUNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkZWwgPSB0aGlzLmVsLFxuICAgICAgICAgICAgICBkYXRhID0gX3RoaXMkZWwuZGF0YSxcbiAgICAgICAgICAgICAgbGF5b3V0ID0gX3RoaXMkZWwubGF5b3V0O1xuICAgICAgICAgIHZhciBmcmFtZXMgPSB0aGlzLmVsLl90cmFuc2l0aW9uRGF0YSA/IHRoaXMuZWwuX3RyYW5zaXRpb25EYXRhLl9mcmFtZXMgOiBudWxsO1xuICAgICAgICAgIHZhciBmaWd1cmUgPSB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgICAgICAgICBmcmFtZXM6IGZyYW1lc1xuICAgICAgICAgIH07XG4gICAgICAgICAgY2FsbGJhY2soZmlndXJlLCB0aGlzLmVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzeW5jV2luZG93UmVzaXplXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3luY1dpbmRvd1Jlc2l6ZShpbnZva2UpIHtcbiAgICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcm9wcy51c2VSZXNpemVIYW5kbGVyICYmICF0aGlzLnJlc2l6ZUhhbmRsZXIpIHtcbiAgICAgICAgICB0aGlzLnJlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gUGxvdGx5LlBsb3RzLnJlc2l6ZShfdGhpczUuZWwpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemVIYW5kbGVyKTtcblxuICAgICAgICAgIGlmIChpbnZva2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplSGFuZGxlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5wcm9wcy51c2VSZXNpemVIYW5kbGVyICYmIHRoaXMucmVzaXplSGFuZGxlcikge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZUhhbmRsZXIpO1xuICAgICAgICAgIHRoaXMucmVzaXplSGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0UmVmXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVmKGVsKSB7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcblxuICAgICAgICBpZiAodGhpcy5wcm9wcy5kZWJ1ZyAmJiBpc0Jyb3dzZXIpIHtcbiAgICAgICAgICB3aW5kb3cuZ2QgPSB0aGlzLmVsO1xuICAgICAgICB9XG4gICAgICB9IC8vIEF0dGFjaCBhbmQgcmVtb3ZlIGV2ZW50IGhhbmRsZXJzIGFzIHRoZXkncmUgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHByb3BzOlxuXG4gICAgfSwge1xuICAgICAga2V5OiBcInN5bmNFdmVudEhhbmRsZXJzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc3luY0V2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAgIGV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBfdGhpczYucHJvcHNbJ29uJyArIGV2ZW50TmFtZV07XG4gICAgICAgICAgdmFyIGhhbmRsZXIgPSBfdGhpczYuaGFuZGxlcnNbZXZlbnROYW1lXTtcbiAgICAgICAgICB2YXIgaGFzSGFuZGxlciA9IEJvb2xlYW4oaGFuZGxlcik7XG5cbiAgICAgICAgICBpZiAocHJvcCAmJiAhaGFzSGFuZGxlcikge1xuICAgICAgICAgICAgX3RoaXM2LmFkZEV2ZW50SGFuZGxlcihldmVudE5hbWUsIHByb3ApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXByb3AgJiYgaGFzSGFuZGxlcikge1xuICAgICAgICAgICAgLy8gTmVlZHMgdG8gYmUgcmVtb3ZlZDpcbiAgICAgICAgICAgIF90aGlzNi5yZW1vdmVFdmVudEhhbmRsZXIoZXZlbnROYW1lKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgJiYgaGFzSGFuZGxlciAmJiBwcm9wICE9PSBoYW5kbGVyKSB7XG4gICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICBfdGhpczYucmVtb3ZlRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSk7XG5cbiAgICAgICAgICAgIF90aGlzNi5hZGRFdmVudEhhbmRsZXIoZXZlbnROYW1lLCBwcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRFdmVudEhhbmRsZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFdmVudEhhbmRsZXIoZXZlbnROYW1lLCBwcm9wKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnNbZXZlbnROYW1lXSA9IHByb3A7XG4gICAgICAgIHRoaXMuZWwub24odGhpcy5nZXRQbG90bHlFdmVudE5hbWUoZXZlbnROYW1lKSwgdGhpcy5oYW5kbGVyc1tldmVudE5hbWVdKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVtb3ZlRXZlbnRIYW5kbGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXZlbnRIYW5kbGVyKGV2ZW50TmFtZSkge1xuICAgICAgICB0aGlzLmVsLnJlbW92ZUxpc3RlbmVyKHRoaXMuZ2V0UGxvdGx5RXZlbnROYW1lKGV2ZW50TmFtZSksIHRoaXMuaGFuZGxlcnNbZXZlbnROYW1lXSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmhhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFBsb3RseUV2ZW50TmFtZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBsb3RseUV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdwbG90bHlfJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgICBpZDogdGhpcy5wcm9wcy5kaXZJZCxcbiAgICAgICAgICBzdHlsZTogdGhpcy5wcm9wcy5zdHlsZSxcbiAgICAgICAgICByZWY6IHRoaXMuZ2V0UmVmLFxuICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5jbGFzc05hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFBsb3RseUNvbXBvbmVudDtcbiAgfShfcmVhY3QuQ29tcG9uZW50KTtcblxuICBQbG90bHlDb21wb25lbnQucHJvcFR5cGVzID0ge1xuICAgIGRhdGE6IF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLmFycmF5T2YoX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0ub2JqZWN0KSxcbiAgICBjb25maWc6IF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgICBsYXlvdXQ6IF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgICBmcmFtZXM6IF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLmFycmF5T2YoX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0ub2JqZWN0KSxcbiAgICByZXZpc2lvbjogX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0ubnVtYmVyLFxuICAgIG9uSW5pdGlhbGl6ZWQ6IF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gICAgb25QdXJnZTogX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0uZnVuYyxcbiAgICBvbkVycm9yOiBfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5mdW5jLFxuICAgIG9uVXBkYXRlOiBfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5mdW5jLFxuICAgIGRlYnVnOiBfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5ib29sLFxuICAgIHN0eWxlOiBfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5vYmplY3QsXG4gICAgY2xhc3NOYW1lOiBfcHJvcFR5cGVzW1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gICAgdXNlUmVzaXplSGFuZGxlcjogX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0uYm9vbCxcbiAgICBkaXZJZDogX3Byb3BUeXBlc1tcImRlZmF1bHRcIl0uc3RyaW5nXG4gIH07XG4gIGV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgUGxvdGx5Q29tcG9uZW50LnByb3BUeXBlc1snb24nICsgZXZlbnROYW1lXSA9IF9wcm9wVHlwZXNbXCJkZWZhdWx0XCJdLmZ1bmM7XG4gIH0pO1xuICBQbG90bHlDb21wb25lbnQuZGVmYXVsdFByb3BzID0ge1xuICAgIGRlYnVnOiBmYWxzZSxcbiAgICB1c2VSZXNpemVIYW5kbGVyOiBmYWxzZSxcbiAgICBkYXRhOiBbXSxcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJ1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFBsb3RseUNvbXBvbmVudDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhY3RvcnkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-plotly.js/factory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-plotly.js/react-plotly.js":
/*!******************************************************!*\
  !*** ./node_modules/react-plotly.js/react-plotly.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _factory = _interopRequireDefault(__webpack_require__(/*! ./factory */ \"(ssr)/./node_modules/react-plotly.js/factory.js\"));\n\nvar _plotly = _interopRequireDefault(__webpack_require__(/*! plotly.js/dist/plotly */ \"(ssr)/./node_modules/plotly.js/dist/plotly.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar PlotComponent = (0, _factory[\"default\"])(_plotly[\"default\"]);\nvar _default = PlotComponent;\nexports[\"default\"] = _default;\n//# sourceMappingURL=react-plotly.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGxvdGx5LmpzL3JlYWN0LXBsb3RseS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCLHNDQUFzQyxtQkFBTyxDQUFDLGtFQUFXOztBQUV6RCxxQ0FBcUMsbUJBQU8sQ0FBQyw0RUFBdUI7O0FBRXBFLHVDQUF1Qyx1Q0FBdUM7O0FBRTlFO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGxvdGx5LmpzL3JlYWN0LXBsb3RseS5qcz8zNWI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfZmFjdG9yeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZmFjdG9yeVwiKSk7XG5cbnZhciBfcGxvdGx5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicGxvdGx5LmpzL2Rpc3QvcGxvdGx5XCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbnZhciBQbG90Q29tcG9uZW50ID0gKDAsIF9mYWN0b3J5W1wiZGVmYXVsdFwiXSkoX3Bsb3RseVtcImRlZmF1bHRcIl0pO1xudmFyIF9kZWZhdWx0ID0gUGxvdENvbXBvbmVudDtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1wbG90bHkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-plotly.js/react-plotly.js\n");

/***/ })

};
;